<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bluetooth People Counting Documentation: VL53L1X</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bluetooth People Counting Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group___v_l53_l1_x.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">VL53L1X</div></div>
</div><!--header-->
<div class="contents">

<p>The implementation of a laser distance sensor using VL53L1X sensor.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvl53l1x__core__version__t.html">vl53l1x_core_version_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for specifying the software version of the core driver.  <a href="structvl53l1x__core__version__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvl53l1x__result__t.html">vl53l1x_result_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for specifying the packed result data.  <a href="structvl53l1x__result__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa81d7339301270cc4c37f9098c551b04"><td class="memItemLeft" align="right" valign="top"><a id="gaa81d7339301270cc4c37f9098c551b04" name="gaa81d7339301270cc4c37f9098c551b04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VL53L1X_DISTANCE_MODE_SHORT</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaa81d7339301270cc4c37f9098c551b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance mode - SHORT (~1.3m range) <br /></td></tr>
<tr class="separator:gaa81d7339301270cc4c37f9098c551b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab93229e54ee65d4798de807363a56c0"><td class="memItemLeft" align="right" valign="top"><a id="gaab93229e54ee65d4798de807363a56c0" name="gaab93229e54ee65d4798de807363a56c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VL53L1X_DISTANCE_MODE_LONG</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gaab93229e54ee65d4798de807363a56c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance mode - LONG (~4m range) <br /></td></tr>
<tr class="separator:gaab93229e54ee65d4798de807363a56c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0df545ed608d6f1b8e6c0acd8f1517c"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gad0df545ed608d6f1b8e6c0acd8f1517c">vl53l1x_init</a> (uint16_t dev)</td></tr>
<tr class="memdesc:gad0df545ed608d6f1b8e6c0acd8f1517c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the 135 bytes default values to initialize the sensor.  <a href="group___v_l53_l1_x.html#gad0df545ed608d6f1b8e6c0acd8f1517c">More...</a><br /></td></tr>
<tr class="separator:gad0df545ed608d6f1b8e6c0acd8f1517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90643facbef9a0cb48738546c0c9968f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga90643facbef9a0cb48738546c0c9968f">vl53l1x_set_i2cspm_instance</a> (sl_i2cspm_t *i2cspm_instance)</td></tr>
<tr class="memdesc:ga90643facbef9a0cb48738546c0c9968f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the IC2SPM instance used by platform functions.  <a href="group___v_l53_l1_x.html#ga90643facbef9a0cb48738546c0c9968f">More...</a><br /></td></tr>
<tr class="separator:ga90643facbef9a0cb48738546c0c9968f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e2d4d0b12ccb5b2099e6b249d7cae7"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga47e2d4d0b12ccb5b2099e6b249d7cae7">vl53l1x_start_ranging</a> (uint16_t dev)</td></tr>
<tr class="memdesc:ga47e2d4d0b12ccb5b2099e6b249d7cae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts the ranging distance operation<br  />
 The ranging operation is continuous. The clear interrupt has to be done after each get data to allow the interrupt to raise when the next data is ready<br  />
 1=active high (default), 0=active low, use SetInterruptPolarity() to change the interrupt polarity if required.  <a href="group___v_l53_l1_x.html#ga47e2d4d0b12ccb5b2099e6b249d7cae7">More...</a><br /></td></tr>
<tr class="separator:ga47e2d4d0b12ccb5b2099e6b249d7cae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7799b65a41dc63828a370104b45f0bf2"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga7799b65a41dc63828a370104b45f0bf2">vl53l1x_stop_ranging</a> (uint16_t dev)</td></tr>
<tr class="memdesc:ga7799b65a41dc63828a370104b45f0bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the ranging.  <a href="group___v_l53_l1_x.html#ga7799b65a41dc63828a370104b45f0bf2">More...</a><br /></td></tr>
<tr class="separator:ga7799b65a41dc63828a370104b45f0bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c1fff44c0947019cff0fd8fe96ea93a"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga0c1fff44c0947019cff0fd8fe96ea93a">vl53l1x_set_i2c_address</a> (uint16_t dev, uint8_t new_address)</td></tr>
<tr class="memdesc:ga0c1fff44c0947019cff0fd8fe96ea93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the I2C address of the device.  <a href="group___v_l53_l1_x.html#ga0c1fff44c0947019cff0fd8fe96ea93a">More...</a><br /></td></tr>
<tr class="separator:ga0c1fff44c0947019cff0fd8fe96ea93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb5d6a3a70d40b9e37449a0f18d1b67"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga6bb5d6a3a70d40b9e37449a0f18d1b67">vl53l1x_clear_interrupt</a> (uint16_t dev)</td></tr>
<tr class="memdesc:ga6bb5d6a3a70d40b9e37449a0f18d1b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the interrupt, to be called after a ranging data reading to arm the interrupt for the next data ready event.  <a href="group___v_l53_l1_x.html#ga6bb5d6a3a70d40b9e37449a0f18d1b67">More...</a><br /></td></tr>
<tr class="separator:ga6bb5d6a3a70d40b9e37449a0f18d1b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6eaa8ffe170f88adf5932f2d0170154"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaf6eaa8ffe170f88adf5932f2d0170154">vl53l1x_set_interrupt_polarity</a> (uint16_t dev, uint8_t int_pol)</td></tr>
<tr class="memdesc:gaf6eaa8ffe170f88adf5932f2d0170154"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the interrupt polarity<br  />
 1=active high (default), 0=active low.  <a href="group___v_l53_l1_x.html#gaf6eaa8ffe170f88adf5932f2d0170154">More...</a><br /></td></tr>
<tr class="separator:gaf6eaa8ffe170f88adf5932f2d0170154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c77a5f461d276e5303812021863faca"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga3c77a5f461d276e5303812021863faca">vl53l1x_get_interrupt_polarity</a> (uint16_t dev, uint8_t *int_pol)</td></tr>
<tr class="memdesc:ga3c77a5f461d276e5303812021863faca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the interrupt polarity<br  />
 1=active high (default), 0=active low.  <a href="group___v_l53_l1_x.html#ga3c77a5f461d276e5303812021863faca">More...</a><br /></td></tr>
<tr class="separator:ga3c77a5f461d276e5303812021863faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bd93a2d14f54693787c1b3a4aaf8876"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga8bd93a2d14f54693787c1b3a4aaf8876">vl53l1x_check_for_data_ready</a> (uint16_t dev, uint8_t *is_data_ready)</td></tr>
<tr class="memdesc:ga8bd93a2d14f54693787c1b3a4aaf8876"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the new ranging data is available by polling the dedicated register.  <a href="group___v_l53_l1_x.html#ga8bd93a2d14f54693787c1b3a4aaf8876">More...</a><br /></td></tr>
<tr class="separator:ga8bd93a2d14f54693787c1b3a4aaf8876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2e563efc24e2dc6b727a41b96087cf"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gada2e563efc24e2dc6b727a41b96087cf">vl53l1x_set_timing_budget_in_ms</a> (uint16_t dev, uint16_t timing_budget_in_ms)</td></tr>
<tr class="memdesc:gada2e563efc24e2dc6b727a41b96087cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the timing budget in ms. Predefined values = 15, 20, 33, 50, 100(default), 200, 500.  <a href="group___v_l53_l1_x.html#gada2e563efc24e2dc6b727a41b96087cf">More...</a><br /></td></tr>
<tr class="separator:gada2e563efc24e2dc6b727a41b96087cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b8d267db7a1489d02c6b45e688c2b6"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga22b8d267db7a1489d02c6b45e688c2b6">vl53l1x_get_timing_budget_in_ms</a> (uint16_t dev, uint16_t *timing_budget_in_ms)</td></tr>
<tr class="memdesc:ga22b8d267db7a1489d02c6b45e688c2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current timing budget in ms.  <a href="group___v_l53_l1_x.html#ga22b8d267db7a1489d02c6b45e688c2b6">More...</a><br /></td></tr>
<tr class="separator:ga22b8d267db7a1489d02c6b45e688c2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc307e3dd0d12841fe2ca6fbc6fc3fd"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga5dc307e3dd0d12841fe2ca6fbc6fc3fd">vl53l1x_set_distance_mode</a> (uint16_t dev, uint16_t distance_mode)</td></tr>
<tr class="memdesc:ga5dc307e3dd0d12841fe2ca6fbc6fc3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the distance mode (1=short, 2=long(default)). Short mode max distance is limited to 1.3 m but better ambient immunity.<br  />
 Long mode can range up to 4 m in the dark with 200 ms timing budget.  <a href="group___v_l53_l1_x.html#ga5dc307e3dd0d12841fe2ca6fbc6fc3fd">More...</a><br /></td></tr>
<tr class="separator:ga5dc307e3dd0d12841fe2ca6fbc6fc3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ff4633eec981b8994f2121aaf8deb6"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gad2ff4633eec981b8994f2121aaf8deb6">vl53l1x_get_distance_mode</a> (uint16_t dev, uint16_t *distance_mode)</td></tr>
<tr class="memdesc:gad2ff4633eec981b8994f2121aaf8deb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current distance mode (1=short, 2=long).  <a href="group___v_l53_l1_x.html#gad2ff4633eec981b8994f2121aaf8deb6">More...</a><br /></td></tr>
<tr class="separator:gad2ff4633eec981b8994f2121aaf8deb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb677df5a9fc52f4485530828b3a7a77"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gacb677df5a9fc52f4485530828b3a7a77">vl53l1x_set_inter_measurement_in_ms</a> (uint16_t dev, uint32_t inter_measurement_in_ms)</td></tr>
<tr class="memdesc:gacb677df5a9fc52f4485530828b3a7a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the Intermeasurement period in ms<br  />
 Intermeasurement period must be &gt;/= timing budget. This condition is not checked by the API, the customer has the duty to check the condition. Default = 100 ms.  <a href="group___v_l53_l1_x.html#gacb677df5a9fc52f4485530828b3a7a77">More...</a><br /></td></tr>
<tr class="separator:gacb677df5a9fc52f4485530828b3a7a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8288bb637569d24391ca5c9dc2141af"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaf8288bb637569d24391ca5c9dc2141af">vl53l1x_get_inter_measurement_in_ms</a> (uint16_t dev, uint16_t *inter_measurement_in_ms)</td></tr>
<tr class="memdesc:gaf8288bb637569d24391ca5c9dc2141af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the Intermeasurement period in ms.  <a href="group___v_l53_l1_x.html#gaf8288bb637569d24391ca5c9dc2141af">More...</a><br /></td></tr>
<tr class="separator:gaf8288bb637569d24391ca5c9dc2141af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeadf44f6f06dd8143361cd3b325b64f1"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaeadf44f6f06dd8143361cd3b325b64f1">vl53l1x_get_boot_state</a> (uint16_t dev, uint8_t *state)</td></tr>
<tr class="memdesc:gaeadf44f6f06dd8143361cd3b325b64f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the boot state of the device (1:booted, 0:not booted).  <a href="group___v_l53_l1_x.html#gaeadf44f6f06dd8143361cd3b325b64f1">More...</a><br /></td></tr>
<tr class="separator:gaeadf44f6f06dd8143361cd3b325b64f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7646b273f335c67873591a23af51b5f6"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga7646b273f335c67873591a23af51b5f6">vl53l1x_get_sensor_id</a> (uint16_t dev, uint16_t *id)</td></tr>
<tr class="memdesc:ga7646b273f335c67873591a23af51b5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the sensor id, sensor Id must be 0xEEAC.  <a href="group___v_l53_l1_x.html#ga7646b273f335c67873591a23af51b5f6">More...</a><br /></td></tr>
<tr class="separator:ga7646b273f335c67873591a23af51b5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a8bfec9da3e94c2bd83fc91aecba0e"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gab9a8bfec9da3e94c2bd83fc91aecba0e">vl53l1x_get_distance</a> (uint16_t dev, uint16_t *distance)</td></tr>
<tr class="memdesc:gab9a8bfec9da3e94c2bd83fc91aecba0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the distance measured by the sensor in mm.  <a href="group___v_l53_l1_x.html#gab9a8bfec9da3e94c2bd83fc91aecba0e">More...</a><br /></td></tr>
<tr class="separator:gab9a8bfec9da3e94c2bd83fc91aecba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga520309c3f3d44d554259793ad8546a57"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga520309c3f3d44d554259793ad8546a57">vl53l1x_get_signal_per_spad</a> (uint16_t dev, uint16_t *signal_per_spad)</td></tr>
<tr class="memdesc:ga520309c3f3d44d554259793ad8546a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the returned signal per SPAD in kcps/SPAD. With kcps stands for Kilo Count Per Second.  <a href="group___v_l53_l1_x.html#ga520309c3f3d44d554259793ad8546a57">More...</a><br /></td></tr>
<tr class="separator:ga520309c3f3d44d554259793ad8546a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf407332afa4052bd681fdbffa68039cd"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaf407332afa4052bd681fdbffa68039cd">vl53l1x_get_ambient_per_spad</a> (uint16_t dev, uint16_t *ambient)</td></tr>
<tr class="memdesc:gaf407332afa4052bd681fdbffa68039cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the ambient per SPAD in kcps/SPAD.  <a href="group___v_l53_l1_x.html#gaf407332afa4052bd681fdbffa68039cd">More...</a><br /></td></tr>
<tr class="separator:gaf407332afa4052bd681fdbffa68039cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae586e25771343f3bb20dd270977809e6"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gae586e25771343f3bb20dd270977809e6">vl53l1x_get_signal_rate</a> (uint16_t dev, uint16_t *signal_rate)</td></tr>
<tr class="memdesc:gae586e25771343f3bb20dd270977809e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the returned signal in kcps.  <a href="group___v_l53_l1_x.html#gae586e25771343f3bb20dd270977809e6">More...</a><br /></td></tr>
<tr class="separator:gae586e25771343f3bb20dd270977809e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca802ae322c0e8911711411903ee9b37"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaca802ae322c0e8911711411903ee9b37">vl53l1x_get_spads_enabled</a> (uint16_t dev, uint16_t *spads_enabled)</td></tr>
<tr class="memdesc:gaca802ae322c0e8911711411903ee9b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current number of enabled SPADs.  <a href="group___v_l53_l1_x.html#gaca802ae322c0e8911711411903ee9b37">More...</a><br /></td></tr>
<tr class="separator:gaca802ae322c0e8911711411903ee9b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad694e4ab1a539855e89d9ded2da209"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga1ad694e4ab1a539855e89d9ded2da209">vl53l1x_get_ambient_rate</a> (uint16_t dev, uint16_t *ambient_rate)</td></tr>
<tr class="memdesc:ga1ad694e4ab1a539855e89d9ded2da209"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the ambient rate in kcps.  <a href="group___v_l53_l1_x.html#ga1ad694e4ab1a539855e89d9ded2da209">More...</a><br /></td></tr>
<tr class="separator:ga1ad694e4ab1a539855e89d9ded2da209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf782afd61d56cb5b82414aadc0dc1a8f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaf782afd61d56cb5b82414aadc0dc1a8f">vl53l1x_get_range_status</a> (uint16_t dev, uint8_t *range_status)</td></tr>
<tr class="memdesc:gaf782afd61d56cb5b82414aadc0dc1a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the ranging status error <br  />
 (0:no error, 1:sigma failed, 2:signal failed, ..., 7:wrap-around)  <a href="group___v_l53_l1_x.html#gaf782afd61d56cb5b82414aadc0dc1a8f">More...</a><br /></td></tr>
<tr class="separator:gaf782afd61d56cb5b82414aadc0dc1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76eae06d6723615165ecf7d7657bf6af"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga76eae06d6723615165ecf7d7657bf6af">vl53l1x_get_result</a> (uint16_t dev, <a class="el" href="structvl53l1x__result__t.html">vl53l1x_result_t</a> *result)</td></tr>
<tr class="memdesc:ga76eae06d6723615165ecf7d7657bf6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns measurements and the range status in a single read access.  <a href="group___v_l53_l1_x.html#ga76eae06d6723615165ecf7d7657bf6af">More...</a><br /></td></tr>
<tr class="separator:ga76eae06d6723615165ecf7d7657bf6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615bf9cc59f292f2b448946b3b136f7c"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga615bf9cc59f292f2b448946b3b136f7c">vl53l1x_set_offset</a> (uint16_t dev, int16_t offset_value)</td></tr>
<tr class="memdesc:ga615bf9cc59f292f2b448946b3b136f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the offset correction in mm.  <a href="group___v_l53_l1_x.html#ga615bf9cc59f292f2b448946b3b136f7c">More...</a><br /></td></tr>
<tr class="separator:ga615bf9cc59f292f2b448946b3b136f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae56e0c0485b2d082be86d4005f60281"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaae56e0c0485b2d082be86d4005f60281">vl53l1x_get_offset</a> (uint16_t dev, int16_t *offset)</td></tr>
<tr class="memdesc:gaae56e0c0485b2d082be86d4005f60281"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the programmed offset correction value in mm.  <a href="group___v_l53_l1_x.html#gaae56e0c0485b2d082be86d4005f60281">More...</a><br /></td></tr>
<tr class="separator:gaae56e0c0485b2d082be86d4005f60281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a57911828c80e0f190bddf5b6ba14f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gae2a57911828c80e0f190bddf5b6ba14f">vl53l1x_set_xtalk</a> (uint16_t dev, uint16_t x_talk_value)</td></tr>
<tr class="memdesc:gae2a57911828c80e0f190bddf5b6ba14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the xtalk correction value in cps (Count Per Second).<br  />
This is the number of photons reflected back from the cover glass in cps.  <a href="group___v_l53_l1_x.html#gae2a57911828c80e0f190bddf5b6ba14f">More...</a><br /></td></tr>
<tr class="separator:gae2a57911828c80e0f190bddf5b6ba14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02cbf3a73dc86fd4d1874d9afd12b5ba"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga02cbf3a73dc86fd4d1874d9afd12b5ba">vl53l1x_get_xtalk</a> (uint16_t dev, uint16_t *x_talk_value)</td></tr>
<tr class="memdesc:ga02cbf3a73dc86fd4d1874d9afd12b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current programmed xtalk correction value in cps.  <a href="group___v_l53_l1_x.html#ga02cbf3a73dc86fd4d1874d9afd12b5ba">More...</a><br /></td></tr>
<tr class="separator:ga02cbf3a73dc86fd4d1874d9afd12b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2a8f87fa07b8f5b4c22e1ba326c00a"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga0c2a8f87fa07b8f5b4c22e1ba326c00a">vl53l1x_set_distance_threshold</a> (uint16_t dev, uint16_t threshold_low, uint16_t threshold_high, uint8_t window)</td></tr>
<tr class="memdesc:ga0c2a8f87fa07b8f5b4c22e1ba326c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the threshold detection mode<br  />
Example:<br  />
vl53l1x_set_distance_threshold(dev,100,300,0): Below 100 <br  />
vl53l1x_set_distance_threshold(dev,100,300,1): Above 300 <br  />
vl53l1x_set_distance_threshold(dev,100,300,2): Out of window <br  />
vl53l1x_set_distance_threshold(dev,100,300,3): In window <br  />
.  <a href="group___v_l53_l1_x.html#ga0c2a8f87fa07b8f5b4c22e1ba326c00a">More...</a><br /></td></tr>
<tr class="separator:ga0c2a8f87fa07b8f5b4c22e1ba326c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3eccf3a5a1eb3ef9804ff21dc7e464"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gabf3eccf3a5a1eb3ef9804ff21dc7e464">vl53l1x_set_distance_threshold_window_mode</a> (uint16_t dev, uint16_t *window)</td></tr>
<tr class="memdesc:gabf3eccf3a5a1eb3ef9804ff21dc7e464"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the window detection mode (0=below; 1=above; 2=out; 3=in)  <a href="group___v_l53_l1_x.html#gabf3eccf3a5a1eb3ef9804ff21dc7e464">More...</a><br /></td></tr>
<tr class="separator:gabf3eccf3a5a1eb3ef9804ff21dc7e464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e6ff525f4d56f2b3c682b50763a4bad"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga4e6ff525f4d56f2b3c682b50763a4bad">vl53l1x_get_distance_threshold_low</a> (uint16_t dev, uint16_t *low)</td></tr>
<tr class="memdesc:ga4e6ff525f4d56f2b3c682b50763a4bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the low threshold in mm.  <a href="group___v_l53_l1_x.html#ga4e6ff525f4d56f2b3c682b50763a4bad">More...</a><br /></td></tr>
<tr class="separator:ga4e6ff525f4d56f2b3c682b50763a4bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6541968207bba2e1c53f7eb0935a2e"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga2e6541968207bba2e1c53f7eb0935a2e">vl53l1x_get_distance_threshold_high</a> (uint16_t dev, uint16_t *high)</td></tr>
<tr class="memdesc:ga2e6541968207bba2e1c53f7eb0935a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the high threshold in mm.  <a href="group___v_l53_l1_x.html#ga2e6541968207bba2e1c53f7eb0935a2e">More...</a><br /></td></tr>
<tr class="separator:ga2e6541968207bba2e1c53f7eb0935a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22936ea873fda587bd7ccf1917ef93d2"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga22936ea873fda587bd7ccf1917ef93d2">vl53l1x_set_roi_xy</a> (uint16_t dev, uint16_t x, uint16_t y)</td></tr>
<tr class="memdesc:ga22936ea873fda587bd7ccf1917ef93d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the ROI (Region of Interest)<br  />
The ROI position is centered, only the ROI size can be reprogrammed.<br  />
The smallest acceptable ROI size = 4<br  />
.  <a href="group___v_l53_l1_x.html#ga22936ea873fda587bd7ccf1917ef93d2">More...</a><br /></td></tr>
<tr class="separator:ga22936ea873fda587bd7ccf1917ef93d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f1665ba58beaf1e6219f7860e0d178"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaf0f1665ba58beaf1e6219f7860e0d178">vl53l1x_get_roi_xy</a> (uint16_t dev, uint16_t *x, uint16_t *y)</td></tr>
<tr class="memdesc:gaf0f1665ba58beaf1e6219f7860e0d178"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns width X and height Y.  <a href="group___v_l53_l1_x.html#gaf0f1665ba58beaf1e6219f7860e0d178">More...</a><br /></td></tr>
<tr class="separator:gaf0f1665ba58beaf1e6219f7860e0d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2095daf82452a28114bc280a64d873b6"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga2095daf82452a28114bc280a64d873b6">vl53l1x_set_roi_center</a> (uint16_t dev, uint8_t center)</td></tr>
<tr class="memdesc:ga2095daf82452a28114bc280a64d873b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs the new user ROI center, please to be aware that there is no check in this function. if the ROI center vs ROI size is out of border the ranging function return error #13.  <a href="group___v_l53_l1_x.html#ga2095daf82452a28114bc280a64d873b6">More...</a><br /></td></tr>
<tr class="separator:ga2095daf82452a28114bc280a64d873b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d326a4889586e69e8f30b2f7834033"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gad2d326a4889586e69e8f30b2f7834033">vl53l1x_get_roi_center</a> (uint16_t dev, uint8_t *center)</td></tr>
<tr class="memdesc:gad2d326a4889586e69e8f30b2f7834033"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current user ROI center.  <a href="group___v_l53_l1_x.html#gad2d326a4889586e69e8f30b2f7834033">More...</a><br /></td></tr>
<tr class="separator:gad2d326a4889586e69e8f30b2f7834033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad345d9dca887947f49c1ecb70c9b54a5"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gad345d9dca887947f49c1ecb70c9b54a5">vl53l1x_set_signal_threshold</a> (uint16_t dev, uint16_t signal)</td></tr>
<tr class="memdesc:gad345d9dca887947f49c1ecb70c9b54a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs a new signal threshold in kcps (default=1024 kcps)  <a href="group___v_l53_l1_x.html#gad345d9dca887947f49c1ecb70c9b54a5">More...</a><br /></td></tr>
<tr class="separator:gad345d9dca887947f49c1ecb70c9b54a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea9165619cf3172ffb1416d80ad53053"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#gaea9165619cf3172ffb1416d80ad53053">vl53l1x_get_signal_threshold</a> (uint16_t dev, uint16_t *signal)</td></tr>
<tr class="memdesc:gaea9165619cf3172ffb1416d80ad53053"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current signal threshold in kcps.  <a href="group___v_l53_l1_x.html#gaea9165619cf3172ffb1416d80ad53053">More...</a><br /></td></tr>
<tr class="separator:gaea9165619cf3172ffb1416d80ad53053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92dd3b7f1d602d2143bfc8cc0fbbc86b"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga92dd3b7f1d602d2143bfc8cc0fbbc86b">vl53l1x_set_sigma_threshold</a> (uint16_t dev, uint16_t sigma)</td></tr>
<tr class="memdesc:ga92dd3b7f1d602d2143bfc8cc0fbbc86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function programs a new sigma threshold in mm (default=15 mm)  <a href="group___v_l53_l1_x.html#ga92dd3b7f1d602d2143bfc8cc0fbbc86b">More...</a><br /></td></tr>
<tr class="separator:ga92dd3b7f1d602d2143bfc8cc0fbbc86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c78585e954ae7899c6e616cb400240b"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga8c78585e954ae7899c6e616cb400240b">vl53l1x_get_sigma_threshold</a> (uint16_t dev, uint16_t *sigma)</td></tr>
<tr class="memdesc:ga8c78585e954ae7899c6e616cb400240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current sigma threshold in mm.  <a href="group___v_l53_l1_x.html#ga8c78585e954ae7899c6e616cb400240b">More...</a><br /></td></tr>
<tr class="separator:ga8c78585e954ae7899c6e616cb400240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a78d802c86f685aa3a568ca182c01a1"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga7a78d802c86f685aa3a568ca182c01a1">vl53l1x_start_temperature_update</a> (uint16_t dev)</td></tr>
<tr class="memdesc:ga7a78d802c86f685aa3a568ca182c01a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the temperature calibration. It is recommended to call this function any time the temperature might have changed by more than 8 deg C without sensor ranging activity for an extended period.  <a href="group___v_l53_l1_x.html#ga7a78d802c86f685aa3a568ca182c01a1">More...</a><br /></td></tr>
<tr class="separator:ga7a78d802c86f685aa3a568ca182c01a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0fca8d168f9a78dab13ed48bff536f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga8c0fca8d168f9a78dab13ed48bff536f">vl53l1x_get_core_sw_version</a> (<a class="el" href="structvl53l1x__core__version__t.html">vl53l1x_core_version_t</a> *version)</td></tr>
<tr class="memdesc:ga8c0fca8d168f9a78dab13ed48bff536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the Core Software driver version.  <a href="group___v_l53_l1_x.html#ga8c0fca8d168f9a78dab13ed48bff536f">More...</a><br /></td></tr>
<tr class="separator:ga8c0fca8d168f9a78dab13ed48bff536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4859b071888348ce9f9d4a9e654a0922"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga4859b071888348ce9f9d4a9e654a0922">vl53l1x_calibrate_offset</a> (uint16_t dev, uint16_t target_distance_in_mm, int16_t *offset)</td></tr>
<tr class="memdesc:ga4859b071888348ce9f9d4a9e654a0922"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the offset calibration.<br  />
 The function returns the offset value found and programs the offset compensation into the device. Target reflectance = grey17%, recommended distance is 100 mm.  <a href="group___v_l53_l1_x.html#ga4859b071888348ce9f9d4a9e654a0922">More...</a><br /></td></tr>
<tr class="separator:ga4859b071888348ce9f9d4a9e654a0922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f2eecc5e0454df4dee502818dc246a0"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l53_l1_x.html#ga8f2eecc5e0454df4dee502818dc246a0">vl53l1x_calibrate_xtalk</a> (uint16_t dev, uint16_t target_distance_in_mm, uint16_t *xtalk)</td></tr>
<tr class="memdesc:ga8f2eecc5e0454df4dee502818dc246a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the xtalk calibration.<br  />
 The function returns the xtalk value found and programs the xtalk compensation to the device. The target distance :  <a href="group___v_l53_l1_x.html#ga8f2eecc5e0454df4dee502818dc246a0">More...</a><br /></td></tr>
<tr class="separator:ga8f2eecc5e0454df4dee502818dc246a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >The implementation of a laser distance sensor using VL53L1X sensor. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4859b071888348ce9f9d4a9e654a0922" name="ga4859b071888348ce9f9d4a9e654a0922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4859b071888348ce9f9d4a9e654a0922">&#9670;&nbsp;</a></span>vl53l1x_calibrate_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_calibrate_offset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_distance_in_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the offset calibration.<br  />
 The function returns the offset value found and programs the offset compensation into the device. Target reflectance = grey17%, recommended distance is 100 mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_distance_in_mm</td><td>Target distance in mm, ST recommended 100 mm</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>Offset pointer contains the offset found in mm</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if offset is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga8f2eecc5e0454df4dee502818dc246a0" name="ga8f2eecc5e0454df4dee502818dc246a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f2eecc5e0454df4dee502818dc246a0">&#9670;&nbsp;</a></span>vl53l1x_calibrate_xtalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_calibrate_xtalk </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_distance_in_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>xtalk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the xtalk calibration.<br  />
 The function returns the xtalk value found and programs the xtalk compensation to the device. The target distance : </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_distance_in_mm</td><td>Target distance in mm, ST recommended 100 mm<br  />
 the distance where the sensor start to "under range"<br  />
 due to the influence of the photons reflected back from the cover glass becoming strong<br  />
 It's also called inflection point<br  />
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xtalk</td><td>Pointer contains the xtalk value found in cps (number of photons in count per second)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if offset is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga8bd93a2d14f54693787c1b3a4aaf8876" name="ga8bd93a2d14f54693787c1b3a4aaf8876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bd93a2d14f54693787c1b3a4aaf8876">&#9670;&nbsp;</a></span>vl53l1x_check_for_data_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_check_for_data_ready </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_data_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the new ranging data is available by polling the dedicated register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_data_ready</td><td>Data ready. Valid values: [0=No;1=Yes]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga6bb5d6a3a70d40b9e37449a0f18d1b67" name="ga6bb5d6a3a70d40b9e37449a0f18d1b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bb5d6a3a70d40b9e37449a0f18d1b67">&#9670;&nbsp;</a></span>vl53l1x_clear_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_clear_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the interrupt, to be called after a ranging data reading to arm the interrupt for the next data ready event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaf407332afa4052bd681fdbffa68039cd" name="gaf407332afa4052bd681fdbffa68039cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf407332afa4052bd681fdbffa68039cd">&#9670;&nbsp;</a></span>vl53l1x_get_ambient_per_spad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_ambient_per_spad </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ambient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the ambient per SPAD in kcps/SPAD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ambient</td><td>Returns ambient per SPAD in kcps/SPAD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if ambient is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga1ad694e4ab1a539855e89d9ded2da209" name="ga1ad694e4ab1a539855e89d9ded2da209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad694e4ab1a539855e89d9ded2da209">&#9670;&nbsp;</a></span>vl53l1x_get_ambient_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_ambient_rate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ambient_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the ambient rate in kcps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ambient_rate</td><td>Returns the ambient rate in kcps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if ambient_rate is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaeadf44f6f06dd8143361cd3b325b64f1" name="gaeadf44f6f06dd8143361cd3b325b64f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeadf44f6f06dd8143361cd3b325b64f1">&#9670;&nbsp;</a></span>vl53l1x_get_boot_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_boot_state </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the boot state of the device (1:booted, 0:not booted). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>Returns the boot state of the device. (1:booted, 0:not booted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if state is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga8c0fca8d168f9a78dab13ed48bff536f" name="ga8c0fca8d168f9a78dab13ed48bff536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0fca8d168f9a78dab13ed48bff536f">&#9670;&nbsp;</a></span>vl53l1x_get_core_sw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_core_sw_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvl53l1x__core__version__t.html">vl53l1x_core_version_t</a> *&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the Core Software driver version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pVersion</td><td>A structure pointer to store the version of the core driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if pVersion is invalid. </dd></dl>

</div>
</div>
<a id="gab9a8bfec9da3e94c2bd83fc91aecba0e" name="gab9a8bfec9da3e94c2bd83fc91aecba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a8bfec9da3e94c2bd83fc91aecba0e">&#9670;&nbsp;</a></span>vl53l1x_get_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_distance </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the distance measured by the sensor in mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>Returns id of the device. (Must be 0xEEAC)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if distance is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gad2ff4633eec981b8994f2121aaf8deb6" name="gad2ff4633eec981b8994f2121aaf8deb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2ff4633eec981b8994f2121aaf8deb6">&#9670;&nbsp;</a></span>vl53l1x_get_distance_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_distance_mode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>distance_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current distance mode (1=short, 2=long). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance_mode</td><td>Returns distance mode. (1=short, 2=long(default))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga2e6541968207bba2e1c53f7eb0935a2e" name="ga2e6541968207bba2e1c53f7eb0935a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e6541968207bba2e1c53f7eb0935a2e">&#9670;&nbsp;</a></span>vl53l1x_get_distance_threshold_high()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_distance_threshold_high </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the high threshold in mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">high</td><td>High threshold in mm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if high is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga4e6ff525f4d56f2b3c682b50763a4bad" name="ga4e6ff525f4d56f2b3c682b50763a4bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e6ff525f4d56f2b3c682b50763a4bad">&#9670;&nbsp;</a></span>vl53l1x_get_distance_threshold_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_distance_threshold_low </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the low threshold in mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">low</td><td>Low threshold in mm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if low is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaf8288bb637569d24391ca5c9dc2141af" name="gaf8288bb637569d24391ca5c9dc2141af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8288bb637569d24391ca5c9dc2141af">&#9670;&nbsp;</a></span>vl53l1x_get_inter_measurement_in_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_inter_measurement_in_ms </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>inter_measurement_in_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the Intermeasurement period in ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inter_measurement_in_ms</td><td>Returns inter measurement time in ms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if inter_measurement_in_ms is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga3c77a5f461d276e5303812021863faca" name="ga3c77a5f461d276e5303812021863faca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c77a5f461d276e5303812021863faca">&#9670;&nbsp;</a></span>vl53l1x_get_interrupt_polarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_interrupt_polarity </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>int_pol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the interrupt polarity<br  />
 1=active high (default), 0=active low. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">int_pol</td><td>Interrupt line polarity. Valid values: [0;1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaae56e0c0485b2d082be86d4005f60281" name="gaae56e0c0485b2d082be86d4005f60281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae56e0c0485b2d082be86d4005f60281">&#9670;&nbsp;</a></span>vl53l1x_get_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_offset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the programmed offset correction value in mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset_value</td><td>Return the offset correction value programmed in mm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if offset is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaf782afd61d56cb5b82414aadc0dc1a8f" name="gaf782afd61d56cb5b82414aadc0dc1a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf782afd61d56cb5b82414aadc0dc1a8f">&#9670;&nbsp;</a></span>vl53l1x_get_range_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_range_status </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>range_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the ranging status error <br  />
 (0:no error, 1:sigma failed, 2:signal failed, ..., 7:wrap-around) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">range_status</td><td>Returns the ranging status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if range_status is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga76eae06d6723615165ecf7d7657bf6af" name="ga76eae06d6723615165ecf7d7657bf6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76eae06d6723615165ecf7d7657bf6af">&#9670;&nbsp;</a></span>vl53l1x_get_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_result </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvl53l1x__result__t.html">vl53l1x_result_t</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns measurements and the range status in a single read access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Returns the measurement and the range status in a single read access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if result is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gad2d326a4889586e69e8f30b2f7834033" name="gad2d326a4889586e69e8f30b2f7834033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d326a4889586e69e8f30b2f7834033">&#9670;&nbsp;</a></span>vl53l1x_get_roi_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_roi_center </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current user ROI center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">center</td><td>Return the configured ROI center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if center is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaf0f1665ba58beaf1e6219f7860e0d178" name="gaf0f1665ba58beaf1e6219f7860e0d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0f1665ba58beaf1e6219f7860e0d178">&#9670;&nbsp;</a></span>vl53l1x_get_roi_xy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_roi_xy </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns width X and height Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>ROI width.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>ROI height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if x or y is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga7646b273f335c67873591a23af51b5f6" name="ga7646b273f335c67873591a23af51b5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7646b273f335c67873591a23af51b5f6">&#9670;&nbsp;</a></span>vl53l1x_get_sensor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_sensor_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the sensor id, sensor Id must be 0xEEAC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>Returns id of the device. (Must be 0xEEAC)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if id is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga8c78585e954ae7899c6e616cb400240b" name="ga8c78585e954ae7899c6e616cb400240b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c78585e954ae7899c6e616cb400240b">&#9670;&nbsp;</a></span>vl53l1x_get_sigma_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_sigma_threshold </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current sigma threshold in mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma</td><td>Sigma threshold in mm. (default=15 mm)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if sigma is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga520309c3f3d44d554259793ad8546a57" name="ga520309c3f3d44d554259793ad8546a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga520309c3f3d44d554259793ad8546a57">&#9670;&nbsp;</a></span>vl53l1x_get_signal_per_spad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_signal_per_spad </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>signal_per_spad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the returned signal per SPAD in kcps/SPAD. With kcps stands for Kilo Count Per Second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signal_per_spad</td><td>Returns signal per SPAD in kcps/SPAD.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if signal_per_spad is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gae586e25771343f3bb20dd270977809e6" name="gae586e25771343f3bb20dd270977809e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae586e25771343f3bb20dd270977809e6">&#9670;&nbsp;</a></span>vl53l1x_get_signal_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_signal_rate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>signal_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the returned signal in kcps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signal_rate</td><td>Returns returned signal in kcps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if signal_per_spad is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaea9165619cf3172ffb1416d80ad53053" name="gaea9165619cf3172ffb1416d80ad53053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea9165619cf3172ffb1416d80ad53053">&#9670;&nbsp;</a></span>vl53l1x_get_signal_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_signal_threshold </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current signal threshold in kcps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signal</td><td>Signal threshold in kcps. (default=1024 kcps)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if signal is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaca802ae322c0e8911711411903ee9b37" name="gaca802ae322c0e8911711411903ee9b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca802ae322c0e8911711411903ee9b37">&#9670;&nbsp;</a></span>vl53l1x_get_spads_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_spads_enabled </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>spads_enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current number of enabled SPADs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">spads_enabled</td><td>Returns the number of enabled SPADs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if spads_enabled is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga22b8d267db7a1489d02c6b45e688c2b6" name="ga22b8d267db7a1489d02c6b45e688c2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22b8d267db7a1489d02c6b45e688c2b6">&#9670;&nbsp;</a></span>vl53l1x_get_timing_budget_in_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_timing_budget_in_ms </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>timing_budget_in_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current timing budget in ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timing_budget_in_ms</td><td>Timing budget in ms. Valid values: 15, 20, 33, 50, 100(default), 200, 500.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga02cbf3a73dc86fd4d1874d9afd12b5ba" name="ga02cbf3a73dc86fd4d1874d9afd12b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02cbf3a73dc86fd4d1874d9afd12b5ba">&#9670;&nbsp;</a></span>vl53l1x_get_xtalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_get_xtalk </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>x_talk_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current programmed xtalk correction value in cps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x_talk_value</td><td>The Xtalk correction value to program in cps. (Count Per Second)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if x_talk_value is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gad0df545ed608d6f1b8e6c0acd8f1517c" name="gad0df545ed608d6f1b8e6c0acd8f1517c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0df545ed608d6f1b8e6c0acd8f1517c">&#9670;&nbsp;</a></span>vl53l1x_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_init </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the 135 bytes default values to initialize the sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga5dc307e3dd0d12841fe2ca6fbc6fc3fd" name="ga5dc307e3dd0d12841fe2ca6fbc6fc3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dc307e3dd0d12841fe2ca6fbc6fc3fd">&#9670;&nbsp;</a></span>vl53l1x_set_distance_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_distance_mode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>distance_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the distance mode (1=short, 2=long(default)). Short mode max distance is limited to 1.3 m but better ambient immunity.<br  />
 Long mode can range up to 4 m in the dark with 200 ms timing budget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance_mode</td><td>Selects distance mode. (1=short, 2=long(default))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga0c2a8f87fa07b8f5b4c22e1ba326c00a" name="ga0c2a8f87fa07b8f5b4c22e1ba326c00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c2a8f87fa07b8f5b4c22e1ba326c00a">&#9670;&nbsp;</a></span>vl53l1x_set_distance_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_distance_threshold </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>threshold_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>threshold_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the threshold detection mode<br  />
Example:<br  />
vl53l1x_set_distance_threshold(dev,100,300,0): Below 100 <br  />
vl53l1x_set_distance_threshold(dev,100,300,1): Above 300 <br  />
vl53l1x_set_distance_threshold(dev,100,300,2): Out of window <br  />
vl53l1x_set_distance_threshold(dev,100,300,3): In window <br  />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_low</td><td>The threshold under which one the device raises an interrupt if Window = 0 (mm) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_high</td><td>the threshold above which one the device raises an interrupt if Window = 1 (mm) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>Window detection mode : 0=below, 1=above, 2=out, 3=in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if x_talk_value is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gabf3eccf3a5a1eb3ef9804ff21dc7e464" name="gabf3eccf3a5a1eb3ef9804ff21dc7e464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf3eccf3a5a1eb3ef9804ff21dc7e464">&#9670;&nbsp;</a></span>vl53l1x_set_distance_threshold_window_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_distance_threshold_window_mode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the window detection mode (0=below; 1=above; 2=out; 3=in) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">window</td><td>Window detection mode. (0=below; 1=above; 2=out; 3=in)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if window is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga0c1fff44c0947019cff0fd8fe96ea93a" name="ga0c1fff44c0947019cff0fd8fe96ea93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c1fff44c0947019cff0fd8fe96ea93a">&#9670;&nbsp;</a></span>vl53l1x_set_i2c_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_i2c_address </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>new_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the I2C address of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_address</td><td>New address of the selected device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga90643facbef9a0cb48738546c0c9968f" name="ga90643facbef9a0cb48738546c0c9968f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90643facbef9a0cb48738546c0c9968f">&#9670;&nbsp;</a></span>vl53l1x_set_i2cspm_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_i2cspm_instance </td>
          <td>(</td>
          <td class="paramtype">sl_i2cspm_t *&#160;</td>
          <td class="paramname"><em>i2cspm_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the IC2SPM instance used by platform functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cspm_instance</td><td>I2CSPM instance, default: VL53L1X_CONFIG_I2C_INSTANCE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. </dd></dl>

</div>
</div>
<a id="gacb677df5a9fc52f4485530828b3a7a77" name="gacb677df5a9fc52f4485530828b3a7a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb677df5a9fc52f4485530828b3a7a77">&#9670;&nbsp;</a></span>vl53l1x_set_inter_measurement_in_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_inter_measurement_in_ms </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inter_measurement_in_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the Intermeasurement period in ms<br  />
 Intermeasurement period must be &gt;/= timing budget. This condition is not checked by the API, the customer has the duty to check the condition. Default = 100 ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inter_measurement_in_ms</td><td>Configures inter measurement time in ms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gaf6eaa8ffe170f88adf5932f2d0170154" name="gaf6eaa8ffe170f88adf5932f2d0170154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6eaa8ffe170f88adf5932f2d0170154">&#9670;&nbsp;</a></span>vl53l1x_set_interrupt_polarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_interrupt_polarity </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_pol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the interrupt polarity<br  />
 1=active high (default), 0=active low. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">int_pol</td><td>Interrupt line polarity. Valid values: [0;1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga615bf9cc59f292f2b448946b3b136f7c" name="ga615bf9cc59f292f2b448946b3b136f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga615bf9cc59f292f2b448946b3b136f7c">&#9670;&nbsp;</a></span>vl53l1x_set_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_offset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the offset correction in mm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_value</td><td>The offset correction value to program in mm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga2095daf82452a28114bc280a64d873b6" name="ga2095daf82452a28114bc280a64d873b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2095daf82452a28114bc280a64d873b6">&#9670;&nbsp;</a></span>vl53l1x_set_roi_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_roi_center </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the new user ROI center, please to be aware that there is no check in this function. if the ROI center vs ROI size is out of border the ranging function return error #13. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>ROI center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga22936ea873fda587bd7ccf1917ef93d2" name="ga22936ea873fda587bd7ccf1917ef93d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22936ea873fda587bd7ccf1917ef93d2">&#9670;&nbsp;</a></span>vl53l1x_set_roi_xy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_roi_xy </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the ROI (Region of Interest)<br  />
The ROI position is centered, only the ROI size can be reprogrammed.<br  />
The smallest acceptable ROI size = 4<br  />
. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>ROI width.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>ROI height.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga92dd3b7f1d602d2143bfc8cc0fbbc86b" name="ga92dd3b7f1d602d2143bfc8cc0fbbc86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92dd3b7f1d602d2143bfc8cc0fbbc86b">&#9670;&nbsp;</a></span>vl53l1x_set_sigma_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_sigma_threshold </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs a new sigma threshold in mm (default=15 mm) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>Sigma threshold in mm. (default=15 mm)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gad345d9dca887947f49c1ecb70c9b54a5" name="gad345d9dca887947f49c1ecb70c9b54a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad345d9dca887947f49c1ecb70c9b54a5">&#9670;&nbsp;</a></span>vl53l1x_set_signal_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_signal_threshold </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs a new signal threshold in kcps (default=1024 kcps) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>Signal threshold in kcps. (default=1024 kcps)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gada2e563efc24e2dc6b727a41b96087cf" name="gada2e563efc24e2dc6b727a41b96087cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2e563efc24e2dc6b727a41b96087cf">&#9670;&nbsp;</a></span>vl53l1x_set_timing_budget_in_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_timing_budget_in_ms </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timing_budget_in_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the timing budget in ms. Predefined values = 15, 20, 33, 50, 100(default), 200, 500. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timing_budget_in_ms</td><td>Timing budget in ms. Valid values: 15, 20, 33, 50, 100(default), 200, 500.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_INVALID_PARAMETER if int_pol is invalid. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="gae2a57911828c80e0f190bddf5b6ba14f" name="gae2a57911828c80e0f190bddf5b6ba14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a57911828c80e0f190bddf5b6ba14f">&#9670;&nbsp;</a></span>vl53l1x_set_xtalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_set_xtalk </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x_talk_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function programs the xtalk correction value in cps (Count Per Second).<br  />
This is the number of photons reflected back from the cover glass in cps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_talk_value</td><td>The Xtalk correction value to program in cps. (Count Per Second)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga47e2d4d0b12ccb5b2099e6b249d7cae7" name="ga47e2d4d0b12ccb5b2099e6b249d7cae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e2d4d0b12ccb5b2099e6b249d7cae7">&#9670;&nbsp;</a></span>vl53l1x_start_ranging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_start_ranging </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the ranging distance operation<br  />
 The ranging operation is continuous. The clear interrupt has to be done after each get data to allow the interrupt to raise when the next data is ready<br  />
 1=active high (default), 0=active low, use SetInterruptPolarity() to change the interrupt polarity if required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga7a78d802c86f685aa3a568ca182c01a1" name="ga7a78d802c86f685aa3a568ca182c01a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a78d802c86f685aa3a568ca182c01a1">&#9670;&nbsp;</a></span>vl53l1x_start_temperature_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_start_temperature_update </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the temperature calibration. It is recommended to call this function any time the temperature might have changed by more than 8 deg C without sensor ranging activity for an extended period. </p>
<p >This function performs the temperature calibration. It is recommended to call this function any time the temperature might have changed by more than 8 deg C without sensor ranging activity for an extended period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
<a id="ga7799b65a41dc63828a370104b45f0bf2" name="ga7799b65a41dc63828a370104b45f0bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7799b65a41dc63828a370104b45f0bf2">&#9670;&nbsp;</a></span>vl53l1x_stop_ranging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t vl53l1x_stop_ranging </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the ranging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device address. (Default: 0x29[0x52])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if there are no errors. SL_STATUS_TRANSMIT if I2C transmit failed. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
